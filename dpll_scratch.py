# -*- coding: utf-8 -*-
"""DPLL Scratch

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OYIP8cCL-hWkPj95McU55XEDO6_VXLwL
"""

from enum import Enum
from collections import deque
from collections import defaultdict
from random import randrange
import operator

class State(Enum):
  TRIED_NONE = 0
  TRIED_FALSE = 1
  TRIED_TRUE = 2
  TRIED_BOTH = 3

  def attempted(state, to_try):
    if state == State.TRIED_NONE:
      if to_try:
        return State.TRIED_TRUE
      else:
        return State.TRIED_FALSE
    elif ((state == State.TRIED_TRUE) and not to_try) or \
    ((state == State.TRIED_FALSE) and to_try):
      return State.TRIED_BOTH

  def can_try(state, to_try):
    return (state == State.TRIED_NONE) or \
     (state == State.TRIED_FALSE and to_try) or \
      (state == State.TRIED_TRUE and not to_try)

class Variable():

  def __init__(self, name, index):
    self.name = name
    self.index = index

  def __repr__(self):
    return "Variable: %s, Index: %i" % (self.name, self.index)

  def __str__(self):
    return "Variable: %s, Index: %i" % (self.name, self.index)

class Literal():
  def __init__(self, var, negated):
    self.variable = var
    self.negated = negated

    # For loopup in watchlists, we use -index or index depending on 
    # if the variable is negated. Save that here.
    self.encoding = ("-" if negated else "") + str(self.variable.index)

class Clause():

  def __init__(self, literals):
    self.literals = literals

  def __getitem__(self, index):
    return self.literals[0]

  def __iter__(self):
    return iter(self.literals)

  def __contains__(self, item):
    return item in self.get_variable_indexes()

  def get_variable_indexes(self):
    return [l.variable.index for l in self.literals]

  def count_unassigned(self, assignments):
    count = 0
    for var in self.get_variable_indexes():
      if assignment[var] is None:
        count += 1
    return count

class Instance():

  def __init__(self):
    self.variables = []
    self.variables_lookup = dict()
    self.clauses = []
    self.watchlist = defaultdict(deque)

  def parse_problem(self, string_problem):
    for line in string_problem.splitlines():
      self.add_clause(line)

  def add_clause(self, string_clause):

    cur_clause_list = []

    # Parse the string clause one literal at a time.
    for literal in string_clause.split():

      # Figure out if this literal is negated.
      negated = literal.startswith('-')

      # Capture the variable name.
      variable_name = literal
      if negated:
        variable_name = literal[1:]

      # Get the index of this new variable
      cur_index = len(self.variables)
      var_exists = False

      # If we've already seen this variable, pull up the existing index.
      if variable_name in self.variables_lookup:
        cur_index = self.variables_lookup[variable_name]     
        var_exists = True   

      var = Variable(variable_name, cur_index)

      # If we haven't seen this variable, add it to this instance.
      if not var_exists:
        self.variables.append(var)
        self.variables_lookup[variable_name] = cur_index
      
      # Create an instance of this variable and add to this clause.
      literal = Literal(var, negated)
      cur_clause_list.append(literal)
    
    # Add the completed clause to the clause list.
    cur_clause = Clause(cur_clause_list)
    self.clauses.append(cur_clause)

  def setup_watchlist(self):
    for clause in self.clauses:
      
      # Add the first literal in each clause.
      self.watchlist[clause[0].encoding].append(clause)

  def update_watchlist(self, false_literal, assignment):

    # Repeat updating the watchlist until we don't watch this variable anymore.
    while self.watchlist[false_literal.encoding]:

      alternate_exists = False

      # Look at the first clause being watched by the false literal.
      cur_clause = self.watchlist[false_literal.encoding][0]

      for alt_literal in cur_clause:

        # Calculate the required value of alt_literal to be satisfied.
        sat_value = alt_literal.negated ^ True

        if assignment[alt_literal.variable.index] is None or \
          assignment[alt_literal.variable.index] == sat_value:
          
          # We've found a satisfiable alternate literal.
          alternate_exists = True
          

          # Update the watchlist to show this and break out.
          del self.watchlist[false_literal.encoding][0]
          self.watchlist[alt_literal.encoding].append(cur_clause)
          break
      
      if not alternate_exists:
        return False

    return True

def generate_random_problem(n, l):

  # Start with empty string.
  prob = ""

  # Generate each clause.
  for clause in range(0, l):
    cur_string = ""

    # We are generating 3-SAT problems.
    for i in range(0, 3):

      # Choost a variable and negate it randomly.
      var = randrange(0, n)
      negated = "-" if randrange(0,2) == 1 else ""
      cur_string += "{}x{} ".format(negated, var)

    #Add this clause to the overall problem.
    cur_string += "\n "
    prob += cur_string
  
  # Return and remove last new line.
  return prob[:-3]

def solve(instance, assignment, splitting):

  n = len(instance.variables)
  state = [State(0)] * n

  to_attempt = list(range(0, n))
  previous_attempts = []
  
  while True:
    # if d == n:
    #   yield assignment
    #   d -= 1
    #   continue

    if not to_attempt:
      yield assignment
      
      # Look again at the previously attempted assignment.
      to_attempt.append(previous_attempts.pop())
      continue

    
    # Try the first element of to_attempt.
    idx = splitting(instance, to_attempt, assignment)
    variable_to_try = to_attempt[idx] 
    # print("Attempting %i" % variable_to_try)

    tried_something = False

    for a in [False, True]:

      # Check if we can attempt this assignment.
      if State.can_try(state[variable_to_try], a):

        # Mark this attempt on the state for this variable.
        state[variable_to_try] = State.attempted(state[variable_to_try], a)
        assignment[variable_to_try] = a

        # Record that we attempted a solution.
        tried_something = True

        # If we assign this literal value a, the negated version of this 
        # literal will be false. Ensure that this assignment doesn't cause any 
        # contradictions by updating watchlist.

        false_literal = Literal(instance.variables[variable_to_try], a)
        if instance.update_watchlist(false_literal, assignment):
          # The proposed assignment is okay, keep it.
          # print("   attempted %i, succeed."% a)

          # d += 1
          previous_attempts.append(to_attempt.pop(idx))
          break
        else:
          # The proposed assignment causes a contradiction, revert it.
          assignment[variable_to_try] = None
          # print("   attempted %i, failed." % a)



    # If we were unable to attempt a solution, backtrack if possible.
    if not tried_something:
      # if d == 0splitting:
      if not previous_attempts:

        # Nowhere else to backtrack, no solutions.
        return

      else:

        state[variable_to_try] = State(0)
        assignment[variable_to_try] = None
        to_attempt.insert(idx, previous_attempts.pop())

first_choice = lambda instance, to_attempt, assignment: 0
random_choice = lambda instance, to_attempt, assignment:  randrange(0, len(to_attempt))
def two_clause_choice(instance, to_attempt, assignment): 
  # print("--TWO CHOICE--")
  # print("  to_attempt: {}".format(to_attempt))
  # print("  assignment: {}".format(assignment))
  counts = defaultdict(int)

  for index in range(0, len(to_attempt)):
    var = to_attempt[index]
    for clause in instance.clauses:
      if var in clause and clause.count_unassigned(assignment) == 2:
        counts[index] += 1

  # print("  counts: {}".format(counts)) 
  
  # No variables exist in 2-clauses, use random.
  if not counts.items():
    ret_val = randrange(0, len(to_attempt))
  else:
    ret_val = max(counts.items(), key=operator.itemgetter(1))[0]

  # print("  returned: %i" % ret_val)
  return ret_val

instance = Instance()

problem = "x1 x3 -x4 \n x4 \n x2 -x3 \n -x5"
instance.parse_problem(problem)
instance.setup_watchlist()

assignment = [None] * len(instance.variables)
results = solve(instance, assignment, first_choice)
solutions = set()
for result in results:
  solutions.add(str(result))

for sol in solutions:
  print(sol)

test_instance = Instance()
clause_test = "x1 x3 -x4"
clause_test_2 = "x5 x6 "
test_instance.add_clause(clause_test)
test_instance.add_clause(clause_test_2)

c_test = test_instance.clauses[0]

rand_instance = Instance()
rand_problem = generate_random_problem(150, 450)

rand_instance.parse_problem(rand_problem)
rand_instance.setup_watchlist()

rand_assignment = [None] * len(rand_instance.variables)
results = solve(rand_instance, rand_assignment, random_choice)
solutions = set()
for result in results:
  solutions.add(str(result))

for sol in solutions:
  print(sol)

